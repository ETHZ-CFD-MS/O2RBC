from abc import ABCMeta, abstractmethod
import numpy as np
import os
from scipy.interpolate import interp1d
import warnings

from HbO2.parse.readRBCData import readAllRBCFields, readRBCPositions
from HbO2.setup.case import SimulationParametersFactory
from HbO2.setup.utils import isGraphCase, isGraphStraightCapillariesCase, isAxisymmetricCase
from HbO2.setup.simulationParameters import IOHbO2ParametersAxisymmetric

from postprocessing.loadSampledRBCFiles import loadSampledRBCs
from utilities.decorators import lazy_property, lazy_function, remove_lazy_properties
from utilities.sort import natural_keys


def make_rbc_data(case_path):
    """
    Factory for RBC data.

    Args:
        case_path (str): path to case

    Returns:
        RBCData instance
    """
    if isGraphCase(case_path):
        if isGraphStraightCapillariesCase(case_path):
            return RBCDataGraphStraightCapillaries(case_path)
        else:
            return RBCDataGraph(case_path)
    elif isAxisymmetricCase(case_path):
        if os.path.exists(os.path.join(case_path, 'domain', 'RBCPositions.txt')):
            return RBCDataAxisymmetricLegacy(case_path)
        else:
            return RBCDataAxisymmetric(case_path)


class RBCData(object):
    """
    Abstract interface to RBC data generated by an OpenFOAM simulation.

    The path indices passed as a method argument are understood to range from 0 to
    self.nPath() - 1.
    """
    __metaclass__ = ABCMeta

    def __init__(self, casePath):
        self.casePath= casePath

    def __len__(self):
        return self.nPath()

    @abstractmethod
    def fieldValue(self, fieldName, xi, pathI):
        """
        Return the given field value at xi on path pathI.

        Args:
            fieldName (str): field name
            xi (float): coordinate for field value computation
            pathI (int): path index
        """
        pass

    @abstractmethod
    def pathField(self, pathI, fieldName):
        """
        Return the field values on the given path.

        Args:
            pathI (int): path index
            fieldName (str): field name
        """
        pass

    @abstractmethod
    def pathCenters(self, pathI):
        """
        Return the RBC center positions along the path with given index.

        Args:
            pathI (int): path index

        Returns:
            List of RBC center positions (list of floats)
        """
        pass

    @abstractmethod
    def pathTimes(self, pathI):
        """
        Return the time values for the path with given index.

        Args:
            pathI (int): path index

        Returns:
            List of times (list of floats)
        """
        pass

    @abstractmethod
    def nPath(self):
        """ Return the number of RBC paths. """
        pass


class RBCDataSampled(RBCData):
    """
    Interface to RBC data generated by an OpenFOAM simulation that outputs separate files
    for each RBC.
    """

    def __init__(self, case_path, sample_dir_name='sampleRBCHb'):
        super(RBCDataSampled, self).__init__(case_path)
        self.sim_params = SimulationParametersFactory().make_sim_params(case_path)
        self.rbc_fields = loadSampledRBCs(case_path, sample_dir_name, cache_paths=False)
        self._change_rbc_field_names()

    def __getitem__(self, pathI):
        """
        Define __getitem__ with the path index as argument.

        Args:
            pathI (int): path index
        """
        RBCName = self.pathIndexToRBCName(pathI)
        return self.rbc_fields[RBCName]

    def __len__(self):
        return self.nPath()

    def fieldValue(self, fieldName, xi, pathI):
        x = self.pathCenters(pathI)
        y = self.pathField(pathI, fieldName)
        f = interp1d(x, y, bounds_error=False)
        return f(xi)

    def pathField(self, pathI, fieldName):
        RBCName = self.pathIndexToRBCName(pathI)
        return self.rbc_fields[RBCName][fieldName]

    def pathCenters(self, pathI):
        return self.pathField(pathI, 'x')

    def pathTimes(self, pathI):
        return self.pathField(pathI, 'time')

    def nPath(self):
        return len(self.rbc_fields)

    def pathIndexToRBCName(self, pathI):
        """
        Transform the path index pathI to the corresponding RBC name.
        """
        return self._pathIndexToRBCName[pathI]

    def deletePath(self, rbc_name):
        del self.rbc_fields[rbc_name]
        remove_lazy_properties(self)

    @lazy_property
    def _pathIndexToRBCName(self):
        return sorted(self.rbc_fields.keys(), key=natural_keys)

    def _change_rbc_field_names(self):
        """Transform the keys for the fields names in self.RBCFields."""
        for RBCName, RBCDict in self.rbc_fields.iteritems():
            RBCDict['Hb_mean'] = RBCDict.pop('mean')
            RBCDict['Hb_min'] = RBCDict.pop('min')
            RBCDict['Hb_max'] = RBCDict.pop('max')


class RBCDataAxisymmetric(RBCDataSampled):
    """
    Interface to RBC data generated by an OpenFOAM simulation in an axisymmetric domain.
    """

    def __init__(self, case_path, sample_dir_name='sampleRBCHb'):
        super(RBCDataAxisymmetric, self).__init__(case_path, sample_dir_name)
        self._remove_incomplete_paths()

    def _remove_incomplete_paths(self):
        """
        Remove RBC data for RBCs that did not go through the whole capillary.
        """
        x_min = 0
        x_max = self.sim_params['domainLength']
        for RBCName in self.rbc_fields.keys():
            x = self.rbc_fields[RBCName]['x']
            if min(x) > x_min or max(x) < x_max:
                del self.rbc_fields[RBCName]
        if self.nPath() == 0:
            warnings.warn('All the RBC paths were considered to be incomplete.', UserWarning)


class RBCDataAxisymmetricLegacy(RBCData):
    """
    Interface to RBC data generated by an OpenFOAM simulation with the old code based on
    OpenFOAM 2.1.1.
    """

    RBCDataPath = 'domain/RBCData'
    RBCPositionsPath = 'domain/RBCPositions.txt'

    def __init__(self, casePath):
        print 'Reading RBC data for %s' % casePath
        super(RBCDataAxisymmetricLegacy, self).__init__(casePath)
        self.RBCFields = readAllRBCFields(os.path.join(casePath, self.RBCDataPath))
        self.RBCPositions, self.times = readRBCPositions(
                                     os.path.join(casePath, self.RBCPositionsPath))
        self.nRBC = len(self.RBCPositions)
        self.domainLength = IOHbO2ParametersAxisymmetric(casePath)['domainLength']
        self.sortedIndexBounds = self.sortedInDomainIndexBounds()

    def fieldValue(self, fieldName, xi, pathI):
        "Return the given field value at xi on path pathI"
        x = self.pathCenters(pathI)
        y = self.pathField(pathI, fieldName)
        f = interp1d(x, y)
        return f(xi)

    def pathField(self, pathI, fieldName):
        RBCI = self.RBCIndex(pathI)
        return self.RBCFields[RBCI][fieldName][self.indexRange(pathI)]

    def pathCenters(self, pathI):
        RBCI = self.RBCIndex(pathI)
        return self.RBCPositions[RBCI]['center'][self.indexRange(pathI)]

    def pathTimes(self, pathI):
        return self.times[self.indexRange(pathI)]

    def coordinateToTime(self, x, pathI):
        "Return time at which the path with index pathI goes through the given coordinate"
        t0 = self.pathTimes(pathI)[0]
        x0 = self.pathCenters(pathI)[0]
        t1 = self.pathTimes(pathI)[-1]
        x1 = self.pathCenters(pathI)[-1]
        return t0 + (t1 - t0)*(x - x0)/(x1 - x0)

    def nPath(self):
        return len(self.sortedIndexBounds)

    def indexRange(self, pathI):
        (i0, i1) = self.indexBounds(pathI)
        return np.arange(i0, i1+1)

    def indexBounds(self, pathI):
        "Return a tuple with the index of the entry and exit times of the i-th path"
        return self.sortedIndexBounds[pathI][0:2]

    def RBCIndex(self, pathI):
        return self.sortedIndexBounds[pathI][2]

    def sortedInDomainIndexBounds(self):
        """Returns an ordered list of tuples (i, j, RBCI), where i is the entry
        index and j the exit index of RBCI"""
        return sorted([(i, j, RBCI) for RBCI in range(self.nRBC)
                                    for i, j in self.inDomainIndexBounds(RBCI)])

    def inDomainIndexBounds(self, RBCI):
        """Returns an ordered list of tuples (i, j), where i is an entry
        index and j an exit index of RBCI. RBCs that do not pass the positions
        0 and domainLength are not included."""
        centers = self.RBCPositions[RBCI]['center']
        entryIndices = self.entryIndex(centers)
        exitIndices  = self.exitIndex(centers)
        if len(entryIndices) < 2 or len(exitIndices) < 2:
            warnings.warn('No complete path for RBC {:d}'.format(RBCI))
            return []
        else:
            if exitIndices[0] < entryIndices[0]:
                del exitIndices[0]
            if entryIndices[-1] > exitIndices[-1]:
                del entryIndices[-1]
        return [(i, j) for i, j in zip(entryIndices, exitIndices)]

    def entryIndex(self, x):
        """Return the indices corresponding to domain entry
        (index of the last negative position)"""
        return positionPassingIndices(x, 0.0, before=True)

    def exitIndex(self, x):
        """Return the indices corresponding to domain exit
        (index of the first position larger than domain length)"""
        return positionPassingIndices(x, self.domainLength, before=False)


class RBCDataGraph(RBCDataSampled):
    """
    Interface to RBC data generated by an OpenFOAM simulation with the graph
    """

    def __init__(self, case_path, sample_dir_name='sampleRBCHb'):
        super(RBCDataGraph, self).__init__(case_path, sample_dir_name)

    def fieldValueOnEdge(self, fieldName, s, eI, pathI):
        """
        Return the field values of a given RBC path on a given edge.

        For values of the s coordinate outside the range of given values, extrapolation is
        used. If positions of the RBCs are repeated (for example due to stalling), the duplicate
        elements are removed.

        Args:
            fieldName (str): field name
            s (np.ndarray): s-coordinates where to return the coordinates
            eI (int): edge index
            pathI (int): path index

        Returns:
            np.ndarray, field values at the required positions
        """
        x = self.pathCentersOnEdge(pathI, eI)
        y = self.pathFieldOnEdge(pathI, eI, fieldName)
        if len(x) <= 1:
            warnings.warn('There must be at least two points on the edge, returning NaN',
                          UserWarning)
            return np.nan*np.ones(s.shape)
        f = interp1d(x, y, fill_value='extrapolate')
        f_val = f(s)
        if np.asarray(np.isfinite(f_val)).all():
            return f_val
        else:
            # warnings.warn("Field interpolation failed on edge {:d} ({:s}). Trying with unique values."
            #               .format(eI, self.pathIndexToRBCName(pathI)), UserWarning)
            unique_x, unique_ids, unique_inverse = np.unique(x, return_index=True, return_inverse=True)
            unique_y = y[unique_ids]
            f = interp1d(unique_x, unique_y, fill_value='extrapolate')
            f_val = f(s)
            if not np.asarray(np.isfinite(f_val)).all():
                warnings.warn("Field interpolation failed again with unique values")
            return f_val

    def pathFieldOnEdge(self, pathI, eI, fieldName):
        ids = self._indicesOnEdge(pathI, eI)
        RBCName = self.pathIndexToRBCName(pathI)
        return self.rbc_fields[RBCName][fieldName][ids]

    def pathCenters(self, pathI):
        return self.pathField(pathI, 'sCoord')

    def pathCentersOnEdge(self, pathI, eI):
        return self.pathFieldOnEdge(pathI, eI, 'sCoord')

    def pathTimesOnEdge(self, pathI, eI):
        return self.pathFieldOnEdge(pathI, eI, 'time')

    def pathEdgeIndices(self, pathI):
        return self.pathField(pathI, 'edgeIndex')

    def pathIntersectsEdge(self, pathI, eI):
        RBCName = self.pathIndexToRBCName(pathI)
        return len(np.where(self.rbc_fields[RBCName]['edgeIndex'] == eI)[0]) >= 2

    @lazy_function
    def edgesOnPath(self, pathI):
        """
        Return a list of edges which intersect the given path

        Args:
            pathI (int): path index

        Returns:
            list of int, edge indices
        """
        RBCName = self.pathIndexToRBCName(pathI)
        eids = self.rbc_fields[RBCName]['edgeIndex']
        return list(set([ei for ei in eids if len(np.where(eids == ei)[0]) >= 2]))

    @lazy_function
    def edgeIntersectingPathIds(self, edge):
        """
        Return a list of RBC path indices that intersect the given edge

        Args:
            edge (int): edge index

        Returns:
            list of int, RBC path indices
        """
        return filter(lambda i: self.pathIntersectsEdge(i, edge),
                      range(self.nPath()))

    @lazy_property
    def nPathOnEdges(self):
        """
        Return a dictionary with the number of paths on each intersected edge.

        Returns:
            dict, keys are edge indices, values are the number of hits
        """
        hits = {}
        for pathI in range(self.nPath()):
            eids = self.edgesOnPath(pathI)
            for ei in eids:
                try:
                    hits[ei] += 1
                except KeyError:
                    hits[ei] = 1
        return hits

    @lazy_function
    def _indicesOnEdge(self, pathI, eI):
        """
        Return the indices on the given path where the edge index equals eI

        Args:
            pathI (int): path index
            eI (int): edge index

        Returns:
            list of int, indices where path pathI is on edge eI
        """
        RBCName = self.pathIndexToRBCName(pathI)
        return [i for i, e in enumerate(self.rbc_fields[RBCName]['edgeIndex'])
                if e == eI]


class RBCDataGraphStraightCapillaries(RBCDataGraph):
    """
    Interface to RBC data generated by an OpenFOAM simulation in an array of
    straight capillaries
    """

    def __init__(self, case_path, sample_dir_name='sampleRBCHb'):
        super(RBCDataGraphStraightCapillaries, self).__init__(case_path, sample_dir_name)
        self._removeIncompletePaths()

    def _removeIncompletePaths(self):
        """
        Remove RBC data for RBCs that did not go through the whole capillary.
        """
        sBounds = self.sim_params.sCoordsInDomain()
        for RBCName in self.rbc_fields.keys():
            sCoord = self.rbc_fields[RBCName]['sCoord']
            if min(sCoord) > sBounds[0] or max(sCoord) < sBounds[1]:
                del self.rbc_fields[RBCName]
        if self.nPath() == 0:
            warnings.warn('All the RBC paths were considered to be incomplete.', UserWarning)


def positionPassingIndices(x, x0, before=True):
    """Return the indices i in x such that x[i] < x0 < x[i+1] (before=True)
    or x[i-1] < x0 <= x[i] (before=False)"""
    indices = [i for i in range(len(x)-1) if x[i] < x0 and x[i+1] >= x0]
    if not before:
        indices = [1 + i for i in indices]
    return indices